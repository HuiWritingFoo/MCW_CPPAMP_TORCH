local wrap = require 'cwrap'

local interface = wrap.CInterface.new()

interface:print('/* WARNING: autogenerated file */')
interface:print('')
interface:print('#include "THC.h"')
interface:print('#include "luaT.h"')
interface:print('#include "utils.h"')
interface:print('')
interface:print('')

-- specific to CUDA
local typename = 'GPUTensor'

-- cut and paste from wrap/types.lua
wrap.types.GPUTensor = {
   
   helpname = function(arg)
                 if arg.dim then
                    return string.format('%s~%dD', typename, arg.dim)
                 else
                    return typename
                 end
              end,
   
   declare = function(arg)
                local txt = {}
                table.insert(txt, string.format("TH%s *arg%d = NULL;", typename, arg.i))
                if arg.returned then
                   table.insert(txt, string.format("int arg%d_idx = 0;", arg.i));
                end
                return table.concat(txt, '\n')
             end,
   
   check = function(arg, idx)
              if arg.dim then
                 return string.format('(arg%d = luaT_toudata(L, %d, "torch.%s")) && (arg%d->nDimension == %d)', arg.i, idx, typename, arg.i, arg.dim)
              else
                 return string.format('(arg%d = luaT_toudata(L, %d, "torch.%s"))', arg.i, idx, typename)
              end
           end,
   
   read = function(arg, idx)
             if arg.returned then
                return string.format("arg%d_idx = %d;", arg.i, idx)
             end
          end,
   
   init = function(arg)
             if type(arg.default) == 'boolean' then
                return string.format('arg%d = TH%s_new();', arg.i, typename)
             elseif type(arg.default) == 'number' then
                return string.format('arg%d = %s;', arg.i, arg.args[arg.default]:carg())
             else
                error('unknown default tensor type value')
             end
          end,
   
   carg = function(arg)
             return string.format('arg%d', arg.i)
          end,
   
   creturn = function(arg)
                return string.format('arg%d', arg.i)
             end,
   
   precall = function(arg)
                local txt = {}
                if arg.default and arg.returned then
                   table.insert(txt, string.format('if(arg%d_idx)', arg.i)) -- means it was passed as arg
                   table.insert(txt, string.format('lua_pushvalue(L, arg%d_idx);', arg.i))
                   table.insert(txt, string.format('else'))
                   if type(arg.default) == 'boolean' then -- boolean: we did a new()
                      table.insert(txt, string.format('luaT_pushudata(L, arg%d, "torch.%s");', arg.i, typename))
                   else  -- otherwise: point on default tensor --> retain
                      table.insert(txt, string.format('{'))
                      table.insert(txt, string.format('TH%s_retain(arg%d);', typename, arg.i)) -- so we need a retain
                      table.insert(txt, string.format('luaT_pushudata(L, arg%d, "torch.%s");', arg.i, typename))
                      table.insert(txt, string.format('}'))
                   end
                elseif arg.default then
                   -- we would have to deallocate the beast later if we did a new
                   -- unlikely anyways, so i do not support it for now
                   if type(arg.default) == 'boolean' then
                      error('a tensor cannot be optional if not returned')
                   end
                elseif arg.returned then
                   table.insert(txt, string.format('lua_pushvalue(L, arg%d_idx);', arg.i))
                end
                return table.concat(txt, '\n')
             end,
   
   postcall = function(arg)
                 local txt = {}
                 if arg.creturned then
                    -- this next line is actually debatable
                    table.insert(txt, string.format('TH%s_retain(arg%d);', typename, arg.i))
                    table.insert(txt, string.format('luaT_pushudata(L, arg%d, "torch.%s");', arg.i, typename))
                 end
                 return table.concat(txt, '\n')
              end
}

wrap.types.LongArg = {

   vararg = true,

   helpname = function(arg)
               return "(LongStorage | dim1 [dim2...])"
            end,

   declare = function(arg)
              return string.format("THLongStorage *arg%d = NULL;", arg.i)
           end,

   init = function(arg)
             if arg.default then
                error('LongArg cannot have a default value')
             end
          end,
   
   check = function(arg, idx)
            return string.format("torch_islongargs(L, %d)", idx)
         end,

   read = function(arg, idx)
             return string.format("arg%d = torch_checklongargs(L, %d);", arg.i, idx)
          end,
   
   carg = function(arg, idx)
             return string.format('arg%d', arg.i)
          end,

   creturn = function(arg, idx)
                return string.format('arg%d', arg.i)
             end,
   
   precall = function(arg)
                local txt = {}
                if arg.returned then
                   table.insert(txt, string.format('luaT_pushudata(L, arg%d, "torch.LongStorage");', arg.i))
                end
                return table.concat(txt, '\n')
             end,

   postcall = function(arg)
                 local txt = {}
                 if arg.creturned then
                    -- this next line is actually debatable
                    table.insert(txt, string.format('THLongStorage_retain(arg%d);', arg.i))
                    table.insert(txt, string.format('luaT_pushudata(L, arg%d, "torch.LongStorage");', arg.i))
                 end
                 if not arg.returned and not arg.creturned then
                    table.insert(txt, string.format('THLongStorage_free(arg%d);', arg.i))
                 end
                 return table.concat(txt, '\n')
              end   
}

function interface.luaname2wrapname(self, name)
   return string.format('gputorch_GPUTensor_%s', name)
end

local function cname(name)
   return string.format('THGPUTensor_%s', name)
end

local function lastdim(argn)
   return function(arg)
             return string.format("THGPUTensor_nDimension(%s)", arg.args[argn]:carg())
          end
end

interface:wrap("zero",
               cname("zero"),
               {{name="GPUTensor", returned=true}})

interface:wrap("fill",
               cname("fill"),
               {{name="GPUTensor", returned=true},
                {name="float"}})

interface:wrap("add",
               cname("add"),
               {{name="GPUTensor",returned=true},
                {name="float"}},
               cname("cadd"),
               {{name="GPUTensor", returned=true},
                {name="float", default=1},
                {name="GPUTensor"}},
               cname("cadd_tst"),
               {{name="GPUTensor", returned=true},
                {name="GPUTensor"},
                {name="float", default=1},
                {name="GPUTensor"}})

interface:wrap("mul",
               cname("mul"),
               {{name="GPUTensor", returned=true},
                {name="float"}})

interface:wrap("div",
               cname("div"),
               {{name="GPUTensor", returned=true},
                {name="float"}})

interface:wrap("cmul",
               cname("cmul"),
               {{name="GPUTensor", returned=true},
                {name="GPUTensor", default=1},
                {name="GPUTensor"}})

interface:wrap("cdiv",
               cname("cdiv"),
               {{name="GPUTensor", returned=true},
                {name="GPUTensor", default=1},
                {name="GPUTensor"}})

interface:wrap("addcmul",
                  cname("addcmul"),
                  {{name="GPUTensor", returned=true},
                   {name="float", default=1},
                   {name="GPUTensor"},
                   {name="GPUTensor"}})

interface:wrap("addcdiv",
               cname("addcdiv"),
               {{name="GPUTensor", returned=true},
                {name="float", default=1},
                {name="GPUTensor"},
                {name="GPUTensor"}})

interface:wrap("dot",
               cname("dot"),
               {{name="GPUTensor"},
                {name="GPUTensor"},
                {name="float", creturned=true}})

for _,name in ipairs({"min", "max", "sum"}) do
   interface:wrap(name,
                  cname(name .. "all"),
                  {{name="GPUTensor"},
                   {name="float", creturned=true}},
                  cname(name),
                  {{name="GPUTensor", default=true, returned=true},
                   {name="GPUTensor"},
                   {name="index"}})
end



for _,name in ipairs({"addmv", "addmm"}) do
   interface:wrap(name,
                  cname(name),
                  {{name="GPUTensor", returned=true},
                   {name="float", default=1, invisible=true}, -- ambiguity
                   {name="float", default=1},
                   {name="GPUTensor"},
                   {name="GPUTensor"}},
                  cname(name),
                  {{name="GPUTensor", returned=true},
                   {name="float"}, -- ambiguity
                   {name="float"},
                   {name="GPUTensor"},
                   {name="GPUTensor"}})
end

interface:wrap("addr",
               cname("addr"),
               {{name="GPUTensor", returned=true},
                {name="float", default=1},
                {name="GPUTensor"},
                {name="GPUTensor"}})

for _,name in ipairs({"log", "log1p", "exp",
                      "cos", "acos", "cosh",
                      "sin", "asin", "sinh",
                      "tan", "atan", "tanh",
                      "sqrt",
                      "ceil", "floor",
                      "abs", "sign"}) do
   
   interface:wrap(name,
                  cname(name),
                  {{name="GPUTensor", returned=true},
                   {name="GPUTensor", default=1}})
   
end

interface:wrap("pow",
               cname("pow"),
               {{name="GPUTensor", returned=true},
                {name="GPUTensor", default=1},
                {name="float"}})

interface:wrap("clamp",
               cname("clamp"),
               {{name="GPUTensor", returned=true},
                {name="GPUTensor", default=1},
                {name="float"},
                {name="float"}})

for _,name in pairs({'lt','gt','le','ge','eq','ne'}) do
   interface:wrap(name,
                  cname(name .. 'Value'),
                  {{name="GPUTensor", default=true, returned=true},
                   {name="GPUTensor"},
                   {name="float"}},
                  cname(name .. 'Tensor'),
                  {{name="GPUTensor", returned=true},
                   {name="GPUTensor"},
                   {name="GPUTensor"}})
end


-- interface:wrap('random',
--                cname("random2"),
--                {{name="GPUTensor", returned=true},
--                 {name='long'},
--                 {name='long'}},
--                cname("random1"),
--                {{name="GPUTensor", returned=true},
--                 {name='long'}},
--                cname("random"),
--                {{name="GPUTensor", returned=true}})

for _,f in ipairs({{name='geometric'},
                   {name='bernoulli', a=0.5}}) do
   
   interface:wrap(f.name,
                  cname(f.name),
                  {{name="GPUTensor", returned=true},
                   {name="float", default=f.a}})
end

for _,f in ipairs({{name='uniform', a=0, b=1},
                   {name='normal', a=0, b=1},
                   {name='cauchy', a=0, b=1},
                   {name='logNormal', a=1, b=2}}) do

   interface:wrap(f.name,
                  cname(f.name),
                  {{name="GPUTensor", returned=true},
                   {name="float", default=f.a},
                   {name="float", default=f.b}})
end

for _,f in ipairs({{name='exponential'}}) do
   
   interface:wrap(f.name,
                  cname(f.name),
                  {{name="GPUTensor", returned=true},
                   {name="float", default=f.a}})
end


interface:wrap("mean",
              cname("meanall"),
              {{name="GPUTensor"},
               {name="float", creturned=true}},
              cname("mean"),
              {{name="GPUTensor", default=true, returned=true},
               {name="GPUTensor"},
               {name="index"}})

for _,name in ipairs({"var", "std"}) do
   interface:wrap(name,
                  cname(name .. "all"),
                  {{name="GPUTensor"},
                   {name="float", creturned=true}})
end

interface:wrap("norm",
               cname("normall"),
                     {{name="GPUTensor"},
                      {name="float", default=2},
                      {name="float", creturned=true}},
               cname("norm"),
                     {{name="GPUTensor", default=true, returned=true},
                      {name="GPUTensor"},
                      {name="float"},
                      {name="index"}})
                      
interface:wrap("renorm",
               cname("renorm"),
                     {{name="GPUTensor", returned=true},
                      {name="GPUTensor", default=1},
                      {name="float"},
                      {name="index"},
                      {name="float"}})

interface:wrap("dist",
               cname("dist"),
               {{name="GPUTensor"},
                {name="GPUTensor"},
                {name="float", default=2},
                {name="float", creturned=true}})
                
interface:wrap("squeeze",
        cname("squeeze"),
        {{name="GPUTensor", default=true, returned=true, postcall=function(arg)
                                                                local txt = {}
                                                                if arg.returned then
                                                                   table.insert(txt, string.format('if(arg%d->nDimension == 1 && arg%d->size[0] == 1)', arg.i, arg.i)) -- number
                                                                   table.insert(txt, string.format('lua_pushnumber(L, (lua_Number)(*THGPUTensor_data(arg%d)));', arg.i))
                                                                end
                                                                return table.concat(txt, '\n')
                                                             end},
         {name="GPUTensor"}},
        cname("squeeze1d"),
        {{name="GPUTensor", default=true, returned=true,

          postcall=
             function(arg)
                local txt = {}
                if arg.returned then
                   table.insert(txt, string.format('if(!hasdims && arg%d->nDimension == 1 && arg%d->size[0] == 1)', arg.i, arg.i)) -- number
                   table.insert(txt, string.format('lua_pushnumber(L, (lua_Number)(*THGPUTensor_data(arg%d)));}', arg.i))
                end
                return table.concat(txt, '\n')
             end},

         {name="GPUTensor",

          precall=
             function(arg)
                return string.format('{int hasdims = arg%d->nDimension > 1;', arg.i)
             end},

         {name="index"}})

interface:register("gputorch_GPUTensorMath__")

   interface:print([[
void gputorch_GPUTensorMath_init(lua_State *L)
{
  luaT_pushmetatable(L, "torch.GPUTensor");
  luaL_register(L, NULL, gputorch_GPUTensorMath__);
  lua_pop(L, 1);
}
]])

interface:tofile(arg[1])
